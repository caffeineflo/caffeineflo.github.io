<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Building a ESP8266 Weather Station with MQTT, HomeKit and WebInterface Part II | [self writeBlog];</title>
<meta name="keywords" content="esp8266, dht11, dht22">
<meta name="description" content="Part II
This is part II of a series of tutorials that build up on each other. If you missed the first part, you can find it here: Part I
Part II is going to be a little bit slower than part I, simply because we have to make a few preparations in order to keep going faster again in part III.
We&rsquo;re going to take a look at MQTT by going over the idea what this protocol does before we go ahead and setup a MQTT server that we&rsquo;re going to use in part III to communicate with our little weather station.">
<meta name="author" content="Florian Harr">
<link rel="canonical" href="https://iflorian.com/esp8266-weather-station-part-2/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.7a798bee3c08158f2ab5c87cad44e192b44f1a9f6625a4a82d811696d8a67786.css" integrity="sha256-enmL7jwIFY8qtch8rUThkrRPGp9mJaSoLYEWltimd4Y=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://iflorian.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://iflorian.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://iflorian.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://iflorian.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://iflorian.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://iflorian.com/esp8266-weather-station-part-2/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>
  mermaid.initialize({ startOnLoad: true, theme: 'default' });
  mermaid.contentLoaded();
</script>
<meta property="og:url" content="https://iflorian.com/esp8266-weather-station-part-2/">
  <meta property="og:site_name" content="[self writeBlog];">
  <meta property="og:title" content="Building a ESP8266 Weather Station with MQTT, HomeKit and WebInterface Part II">
  <meta property="og:description" content="Part II This is part II of a series of tutorials that build up on each other. If you missed the first part, you can find it here: Part I
Part II is going to be a little bit slower than part I, simply because we have to make a few preparations in order to keep going faster again in part III. We’re going to take a look at MQTT by going over the idea what this protocol does before we go ahead and setup a MQTT server that we’re going to use in part III to communicate with our little weather station.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2017-02-09T11:20:20-04:00">
    <meta property="article:modified_time" content="2017-02-09T11:20:20-04:00">
    <meta property="article:tag" content="Esp8266">
    <meta property="article:tag" content="Dht11">
    <meta property="article:tag" content="Dht22">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Building a ESP8266 Weather Station with MQTT, HomeKit and WebInterface Part II">
<meta name="twitter:description" content="Part II
This is part II of a series of tutorials that build up on each other. If you missed the first part, you can find it here: Part I
Part II is going to be a little bit slower than part I, simply because we have to make a few preparations in order to keep going faster again in part III.
We&rsquo;re going to take a look at MQTT by going over the idea what this protocol does before we go ahead and setup a MQTT server that we&rsquo;re going to use in part III to communicate with our little weather station.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://iflorian.com/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Building a ESP8266 Weather Station with MQTT, HomeKit and WebInterface Part II",
      "item": "https://iflorian.com/esp8266-weather-station-part-2/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Building a ESP8266 Weather Station with MQTT, HomeKit and WebInterface Part II",
  "name": "Building a ESP8266 Weather Station with MQTT, HomeKit and WebInterface Part II",
  "description": "Part II This is part II of a series of tutorials that build up on each other. If you missed the first part, you can find it here: Part I\nPart II is going to be a little bit slower than part I, simply because we have to make a few preparations in order to keep going faster again in part III. We\u0026rsquo;re going to take a look at MQTT by going over the idea what this protocol does before we go ahead and setup a MQTT server that we\u0026rsquo;re going to use in part III to communicate with our little weather station.\n",
  "keywords": [
    "esp8266", "dht11", "dht22"
  ],
  "articleBody": "Part II This is part II of a series of tutorials that build up on each other. If you missed the first part, you can find it here: Part I\nPart II is going to be a little bit slower than part I, simply because we have to make a few preparations in order to keep going faster again in part III. We’re going to take a look at MQTT by going over the idea what this protocol does before we go ahead and setup a MQTT server that we’re going to use in part III to communicate with our little weather station.\nMQTT stands for MQ Telemetry Transport and is a lightweight messaging protocol that was build as an easy way to exchange information without much overhead. MQ stands for Message Queueing even though there’s actually no message queueing happening. It’s been standardized since 2013 as the protocol for IOT devices. The standardization society OASIS (Organization for the Advancement of Structured Information Standards) describes MQTT best as:\n“Providing a lightweight publish/subscribe reliable messaging transport protocol suitable for communication in M2M/IoT contexts where a small code footprint is required and/or network bandwidth is at a premium.” The protocol functions in a publish-subscribed way where clients, such as sensors and actors, subscribe to a MQTT broker that opens a channel and processes further actions based on the incoming data. Processing on the broker can be really anything, from further publishing the data to other actors to simply displaying data or triggering another server.\nThis function pattern is best displayed in a graph:\nSource: Hivemq\nWith the recent popularity of IOT and MQTT being defacto the main protocol for most IOT applications there’s a huge variety of software available. A few examples for MQTT brokers that are free for you to use: Mosquitto, Eclipse Paho, Emitter or emqttd. Most of them are open source with a fairly substantial community backing the software. I decided to go with Mosquitto, as it’s one of the more lightweight brokers that’s also available for basically any platform out there.\nI’m going to install Mosquitto on my MacBook Pro. As a big fan of homebrew, the missing macOS package manager, I’m going to use the package they provide for mosquitto.\nTo install Mosquitto with homebrew we only have to run brew install mosquitto and homebrew will do the rest. After the successful installation of mosquitto, homebrew showed us how we can run mosquitto by either executing mosquitto -c /usr/local/etc/mosquitto/mosquitto.conf if we want to run it just now, or brew services start mosquitto if we want to have mosquitto startup now and at restart. I decided to go with the first option, as I don’t need mosquitto every day and want to keep control when to launch it. Once we launched it with mosquitto -c /usr/local/etc/mosquitto/mosquitto.conf we want to know if our server works. So we’re going to open a channel by subscribing to a new topic and then sending a new message. Here’s another screen capture showing you how to do that:\nHere’s step by step what we did:\nWe started mosquitto by executing mosquitto -c /usr/local/etc/mosquitto/mosquitto.conf Once mosquitto started and told us that the server is up and running on port 1883, we opened a new tab on the terminal. This is important! Don’t close the old one as we want the server to keep running. In our new tab, we issued the following command: mosquitto_sub -v -t 'test/topic'. The -v option gave us some more output (verbose), the -t option did let us choose a topic name. Next, we open another tab and issue mosquitto_pub -t 'test/topic' -m 'helloWorld'. We use -t again to specify the topic and -m for the message. If we go back to our second tab now, we see the messages we’ve sent to our topic and if we go back to our first tab, we can see when we connected to our server and when we disconnected. Congratulations! You’ve just setup a MQTT server, published a channel/topic and sent MQTT messages to that channel.\nIn the next part of this series we’re going to use our weather server to publish sensor data to our MQTT server. Once the data reached the MQTT server, we’re going to display the current data and historical data. Stay tuned for the next part of this series!\n",
  "wordCount" : "722",
  "inLanguage": "en",
  "datePublished": "2017-02-09T11:20:20-04:00",
  "dateModified": "2017-02-09T11:20:20-04:00",
  "author":{
    "@type": "Person",
    "name": "Florian Harr"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://iflorian.com/esp8266-weather-station-part-2/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "[self writeBlog];",
    "logo": {
      "@type": "ImageObject",
      "url": "https://iflorian.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://iflorian.com/" accesskey="h" title="[self writeBlog]; (Alt + H)">[self writeBlog];</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://iflorian.com/contact" title="Contact">
                    <span>Contact</span>
                </a>
            </li>
            <li>
                <a href="https://iflorian.com/about" title="About me">
                    <span>About me</span>
                </a>
            </li>
            <li>
                <a href="https://iflorian.com/euc" title="EUC">
                    <span>EUC</span>
                </a>
            </li>
            <li>
                <a href="https://iflorian.com/" title="My Blog">
                    <span>My Blog</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Building a ESP8266 Weather Station with MQTT, HomeKit and WebInterface Part II
    </h1>
    <div class="post-meta"><span title='2017-02-09 11:20:20 -0400 -0400'>February 9, 2017</span>&nbsp;·&nbsp;<span>Florian Harr</span>

</div>
  </header> 
  <div class="post-content"><h1 id="part-ii">Part II<a hidden class="anchor" aria-hidden="true" href="#part-ii">#</a></h1>
<p>This is part II of a series of tutorials that build up on each other. If you missed the first part, you can find it here: <a href="https://iflorian.com/esp8266-weather-station-part-1/">Part I</a></p>
<p>Part II is going to be a little bit slower than part I, simply because we have to make a few preparations in order to keep going faster again in part III.
We&rsquo;re going to take a look at MQTT by going over the idea what this protocol does before we go ahead and setup a MQTT server that we&rsquo;re going to use in part III to communicate with our little weather station.</p>
<p>MQTT stands for MQ Telemetry Transport and is a lightweight messaging protocol that was build as an easy way to exchange information without much overhead. MQ stands for Message Queueing even though there&rsquo;s actually no message queueing happening. It&rsquo;s been standardized since 2013 as the protocol for IOT devices. The standardization society OASIS (Organization for the Advancement of Structured Information Standards) describes MQTT best as:</p>
<blockquote>
<p>&ldquo;Providing a lightweight publish/subscribe reliable messaging transport protocol suitable for communication in M2M/IoT contexts where a small code footprint is required and/or network bandwidth is at a premium.&rdquo;
The protocol functions in a publish-subscribed way where clients, such as sensors and actors, subscribe to a MQTT broker that opens a channel and processes further actions based on the incoming data. Processing on the broker can be really anything, from further publishing the data to other actors to simply displaying data or triggering another server.</p>
</blockquote>
<p>This function pattern is best displayed in a graph:</p>
<p><img alt="MQTT Functioning Pattern" loading="lazy" src="http://www.hivemq.com/wp-content/uploads/Screen-Shot-2014-10-22-at-12.21.07.png">
<em>Source: Hivemq</em></p>
<p>With the recent popularity of IOT and MQTT being defacto the main protocol for most IOT applications there&rsquo;s a huge variety of software available. A few examples for MQTT brokers that are free for you to use: Mosquitto, Eclipse Paho, Emitter or emqttd. Most of them are open source with a fairly substantial community backing the software. I decided to go with Mosquitto, as it&rsquo;s one of the more lightweight brokers that&rsquo;s also available for basically any platform out there.</p>
<p><img alt="Mosquitto" loading="lazy" src="http://projects.eclipse.org/sites/default/files/mosquitto-200px.png"></p>
<p>I&rsquo;m going to install Mosquitto on my MacBook Pro. As a big fan of homebrew, the missing macOS package manager, I&rsquo;m going to use the package they provide for mosquitto.</p>
<p>To install Mosquitto with homebrew we only have to run <code>brew install mosquitto</code> and homebrew will do the rest. After the successful installation of mosquitto, homebrew showed us how we can run mosquitto by either executing <code>mosquitto -c /usr/local/etc/mosquitto/mosquitto.conf</code> if we want to run it just now, or <code>brew services start mosquitto</code> if we want to have mosquitto startup now and at restart.
I decided to go with the first option, as I don&rsquo;t need mosquitto every day and want to keep control when to launch it.
Once we launched it with <code>mosquitto -c /usr/local/etc/mosquitto/mosquitto.conf</code> we want to know if our server works. So we&rsquo;re going to open a channel by subscribing to a new topic and then sending a new message. Here&rsquo;s another screen capture showing you how to do that:</p>
<!-- raw HTML omitted -->
<p>Here&rsquo;s step by step what we did:</p>
<ol>
<li>We started mosquitto by executing <code>mosquitto -c /usr/local/etc/mosquitto/mosquitto.conf</code></li>
<li>Once mosquitto started and told us that the server is up and running on port 1883, we opened a new tab on the terminal. This is important! Don&rsquo;t close the old one as we want the server to keep running.</li>
<li>In our new tab, we issued the following command: <code>mosquitto_sub -v -t 'test/topic'</code>. The -v option gave us some more output (verbose), the -t option did let us choose a topic name.</li>
<li>Next, we open another tab and issue <code>mosquitto_pub -t 'test/topic' -m 'helloWorld'</code>. We use -t again to specify the topic and -m for the message.</li>
<li>If we go back to our second tab now, we see the messages we&rsquo;ve sent to our topic and if we go back to our first tab, we can see when we connected to our server and when we disconnected.</li>
</ol>
<p>Congratulations! You&rsquo;ve just setup a MQTT server, published a channel/topic and sent MQTT messages to that channel.</p>
<p>In the next part of this series we&rsquo;re going to use our weather server to publish sensor data to our MQTT server. Once the data reached the MQTT server, we&rsquo;re going to display the current data and historical data. Stay tuned for the next part of this series!</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://iflorian.com/tags/esp8266/">Esp8266</a></li>
      <li><a href="https://iflorian.com/tags/dht11/">Dht11</a></li>
      <li><a href="https://iflorian.com/tags/dht22/">Dht22</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>All rights reserved - 2024</span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a><script>
(function() {
  'use strict';

  
  const aiContent = document.querySelectorAll('.ai-assisted');
  if (aiContent.length === 0) return;

  
  const STORAGE_KEY = 'ai-indicators-visible';
  const savedState = localStorage.getItem(STORAGE_KEY);
  const isVisible = savedState === 'true';

  
  if (isVisible) {
    document.body.classList.add('ai-indicators-visible');
  }

  
  const button = document.createElement('button');
  button.className = 'ai-toggle-btn';
  button.setAttribute('aria-label', 'Toggle AI content indicators');
  button.setAttribute('aria-pressed', isVisible);
  button.title = isVisible ? 'Hide AI indicators' : 'Show AI indicators';
  button.innerHTML = isVisible ? '✨ Hide AI' : '✨ Show AI';

  
  button.style.cssText = `
    position: fixed;
    bottom: 2rem;
    right: 2rem;
    padding: 0.5rem 1rem;
    background: rgba(139, 92, 246, 0.9);
    color: white;
    border: none;
    border-radius: 2rem;
    cursor: pointer;
    font-size: 0.875rem;
    font-weight: 500;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    transition: all 0.2s ease;
    z-index: 1000;
    font-family: inherit;
  `;

  
  button.addEventListener('mouseenter', function() {
    this.style.background = 'rgba(139, 92, 246, 1)';
    this.style.transform = 'scale(1.05)';
  });

  button.addEventListener('mouseleave', function() {
    this.style.background = 'rgba(139, 92, 246, 0.9)';
    this.style.transform = 'scale(1)';
  });

  
  button.addEventListener('click', function() {
    const newState = !document.body.classList.contains('ai-indicators-visible');

    
    document.body.classList.toggle('ai-indicators-visible');

    
    button.setAttribute('aria-pressed', newState);
    button.title = newState ? 'Hide AI indicators' : 'Show AI indicators';
    button.innerHTML = newState ? '✨ Hide AI' : '✨ Show AI';

    
    localStorage.setItem(STORAGE_KEY, newState);
  });

  
  document.body.appendChild(button);

  
  button.addEventListener('keydown', function(e) {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      this.click();
    }
  });
})();
</script>


<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
