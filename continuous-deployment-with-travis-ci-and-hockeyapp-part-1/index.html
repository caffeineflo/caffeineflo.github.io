<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Continuous Deployment with Travis CI and HockeyApp, Part 1 | [self writeBlog];</title>
<meta name="keywords" content="">
<meta name="description" content="Full disclosure: I wrote this about 1-1.5yrs ago for another company but haven&rsquo;t updated it yet. There&rsquo;s a good chance some stuff is broken, I apologize for that and promise to fix it within the next days ;)
Continuous integration has become an important topic and a significant part of a developer’s workflow. Finding bugs and ensuring a stable codebase are among the most important benefits of using continuous integration. While these benefits are huge on their own, we can extend our continuous integration setup to actually deploy new builds of our application to our testers. We call this extended setup continuous deployment.">
<meta name="author" content="Florian Harr">
<link rel="canonical" href="https://iflorian.com/continuous-deployment-with-travis-ci-and-hockeyapp-part-1/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.a090830a421002426baafbd314e38f149d77b4c48a12ee9312700d770b27fb26.css" integrity="sha256-oJCDCkIQAkJrqvvTFOOPFJ13tMSKEu6TEnANdwsn&#43;yY=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://iflorian.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://iflorian.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://iflorian.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://iflorian.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://iflorian.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://iflorian.com/continuous-deployment-with-travis-ci-and-hockeyapp-part-1/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>
  mermaid.initialize({ startOnLoad: true, theme: 'default' });
  mermaid.contentLoaded();
</script>
<meta property="og:url" content="https://iflorian.com/continuous-deployment-with-travis-ci-and-hockeyapp-part-1/">
  <meta property="og:site_name" content="[self writeBlog];">
  <meta property="og:title" content="Continuous Deployment with Travis CI and HockeyApp, Part 1">
  <meta property="og:description" content="Full disclosure: I wrote this about 1-1.5yrs ago for another company but haven’t updated it yet. There’s a good chance some stuff is broken, I apologize for that and promise to fix it within the next days ;)
Continuous integration has become an important topic and a significant part of a developer’s workflow. Finding bugs and ensuring a stable codebase are among the most important benefits of using continuous integration. While these benefits are huge on their own, we can extend our continuous integration setup to actually deploy new builds of our application to our testers. We call this extended setup continuous deployment.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2016-10-21T17:28:00+00:00">
    <meta property="article:modified_time" content="2016-10-21T17:28:00+00:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Continuous Deployment with Travis CI and HockeyApp, Part 1">
<meta name="twitter:description" content="Full disclosure: I wrote this about 1-1.5yrs ago for another company but haven&rsquo;t updated it yet. There&rsquo;s a good chance some stuff is broken, I apologize for that and promise to fix it within the next days ;)
Continuous integration has become an important topic and a significant part of a developer’s workflow. Finding bugs and ensuring a stable codebase are among the most important benefits of using continuous integration. While these benefits are huge on their own, we can extend our continuous integration setup to actually deploy new builds of our application to our testers. We call this extended setup continuous deployment.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://iflorian.com/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Continuous Deployment with Travis CI and HockeyApp, Part 1",
      "item": "https://iflorian.com/continuous-deployment-with-travis-ci-and-hockeyapp-part-1/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Continuous Deployment with Travis CI and HockeyApp, Part 1",
  "name": "Continuous Deployment with Travis CI and HockeyApp, Part 1",
  "description": "Full disclosure: I wrote this about 1-1.5yrs ago for another company but haven\u0026rsquo;t updated it yet. There\u0026rsquo;s a good chance some stuff is broken, I apologize for that and promise to fix it within the next days ;)\nContinuous integration has become an important topic and a significant part of a developer’s workflow. Finding bugs and ensuring a stable codebase are among the most important benefits of using continuous integration. While these benefits are huge on their own, we can extend our continuous integration setup to actually deploy new builds of our application to our testers. We call this extended setup continuous deployment.\n",
  "keywords": [
    
  ],
  "articleBody": "Full disclosure: I wrote this about 1-1.5yrs ago for another company but haven’t updated it yet. There’s a good chance some stuff is broken, I apologize for that and promise to fix it within the next days ;)\nContinuous integration has become an important topic and a significant part of a developer’s workflow. Finding bugs and ensuring a stable codebase are among the most important benefits of using continuous integration. While these benefits are huge on their own, we can extend our continuous integration setup to actually deploy new builds of our application to our testers. We call this extended setup continuous deployment.\nFor most app developers, setting up an Xcode server and all of the necessary requirements to run a CI server are more of a hassle and a distraction than anything else. There are a couple of alternatives available to this approach, one of them being Travis-CI, a cloud-based continuous integration solution that conveniently takes away the hassle to setup a server.\nIn this series of tutorials, I would like to show you how to set up an existing Xcode project with Travis CI for automated builds. Later on, I’ll show you how to automatically distribute your builds using HockeyApp. Let’s dive right in, starting with Travis CI. The only thing you need in order to follow along is an Xcode project hosted on GitHub.\nIntroducing Travis CI Travis CI is basically a virtual machine provider, which gives us a Mac OS X machine with a software stack on top that includes the latest Xcode, Ruby and homebrew. The complete list of available gems, software and commands can be found in the Travis CI docs.\nTo begin setting up Travis CI, you first need an account. Fortunately, Travis can use your GitHub account and you’re done with that part in one click. Go to travis-ci.org, click on Sign in with GitHub in the upper right corner and log in with your GitHub Account.\nOnce you’re logged in with your GitHub account, Travis shows you your latest CI build in the form of a dashboard. The navigation is divided into three parts. The left sidebar displays your active CI projects with some quick info, the header above gives you some navigation possibilities with your personal settings on the right, and the main area in the center shows your currently selected CI project with the latest build log under the Current tab.\nSettings for your selected CI project are available through the gear icon on the upper right side, next to the build passing/failed/unknown’ button. All the information here is synchronized with GitHub, so new pushes lead to a new build under Build History,’ and any errors or simple logging output can be found in the Terminal-style dark box when you select a build.\nThere’s also an option to build your private repositories, though that’s a feature included only in paid plans, as the free plan is meant to support open source projects. Private repositories are configured through travis-ci.com.\nGet Your Repo Up to Speed Once your repositories are fetched, you can enable your project for use with Travis by using the “ON/OFF” slider. Once you do that, Travis will start building the project even though Travis might not know how to properly do so just yet. I prefer to hold off Travis when no configuration file is available, by selecting “Build only if .travis.yml is present” in the project settings.\nTo do so, click on the + sign in the left sidebar, make sure your desired identity is selected and then activate your repository on the right by using the ON/OFF slider. Next, click on the wrench symbol next to the switch and you’ll get redirected to your project’s settings page. Activate the “Build only if .travis.yml is present” option.\nThis brings us to the core configuration of Travis, the .travis.yml file. All settings, instructions and customized routines are set through Travis’s .travis.yml file, which has to be placed in your repository’s root. Therefore, we go forward and create an empty file with the name .travis.yml in our repository’s root, so Travis continues to build our project.\nNote that you might not see this file through your file explorer, as most operating systems hide files with a dot prefix. Go ahead and commit that file to your repo, and Travis will continue to build it. Either use your favorite text editor or use cd {yourRepositoriy/Path/} | touch .travis.yml to create an empty .travis.yml file in your repo. Commit and push to GitHub. You can and should check the existence of your .travis.yml on your GitHub’s overview page, as shown in the screenshot below.\nNote: Travis’s configuration file follows a customized YAML syntax, which can easily break. When writing the configuration file, be sure to use soft tabs (spaces) instead of real tabs and try to remind yourself that this will be parsed through bash when using whitespaces in commands.\nShared Xcode Schemes Before we move along to the actual build process, we have to configure our project in Xcode to make our build targets available on the server. So far, the build targets have been created automatically, but that doesn’t happen on the server. To make our targets available on the server, we have to declare them as Shared targets. To do this, open your project in Xcode, click on the project’s name next to the Build \u0026 Run Button, where you normally select your deployment target, and select Manage Schemes. You should have at least two targets, one for your actual app and one for your Unit Test target as shown in the screenshot above. If not, go ahead and create them either through the + Button or the Autocreate Schemes Now Button.\nCommit and push to GitHub. Make sure that your commit contains your shared scheme. It’s a common mistake for people to exclude the shared scheme through their .gitignore.\nUnder the Hood At this point, you might ask yourself what Travis performs to build your project. As mentioned before, Travis is basically a VM provider and lets you modify its routine through bash scripts in order to build your projects. It’s no wonder that Travis uses Xcode’s command line tools to perform all actions on your project. The main command is xcodebuild, which is invoked with some basic parameters. The basic pattern goes like this:\nxcodebuild -project {XCodeproject.xcodeproj} -scheme {SchemeNem} -sdk {SDKname} In our specific case, that command would look like this:\nxcodebuild -project ContinuousDistributionExample.xcodeproj -scheme ContinuousDistributionExample -sdk iphonesimulator The required parameters are -project {Path to your .xcodeproj}, -scheme {Your projects scheme name} and -sdk {SDK name} If you have a Xcode workspace instead of a project, exchange the -project parameter for a -workspace parameter. As with most, if not all, of the commands shown here, you can test these commands locally before testing them on Travis CI. For this specific command, just open your terminal and navigate with cd into your repository and execute the same xcodebuild command. That way, you can see if your command works, and if there are any typos or other problems.\nA lot could be said here about how to use xcodebuild, but as there are more advanced tools that work as a wrapper to xcodebuild, we’re going to move along and use xctool to replace it. In any case, you should make sure that your Xcode command line tools are working and up to date. You can check that by performing xcode-select –version in your terminal.\n###The Basic Setup Now that you know how the xcodebuild command works, let’s start using it with Travis CI. Modify the contents of your .travis.yml to match this code snippet, while making the appropriate customizations for your parameters:\n# file: .travis.yml language: objective-c script: - xcodebuild -project ContinuousDistributionExample.xcodeproj -scheme ContinuousDistributionExample -sdk iphonesimulator Travis CI defines a minimal configuration for an Objective-C project to have the keys language, xcode_project and xcode_scheme defined. If you try to use these, Travis will use your project’s default settings, which have a high chance to fail on Travis CI without prior changes. Commit the file, and push your changes to your GitHub repo. If you put in the correct names and paths and you committed your configuration back to GitHub, Travis CI should start building your project. Make sure that the build passes at this point, so we can customize our routine from here. You can tell that your build is passing from either the log by clicking on the Build History tab, or after refreshing the website from the build: status button at the upper right section.\nXCTool xctool is a wrapper for Apple’s xcodebuild, which we were using before. The main purpose for switching from xcodebuild to xctool is to make it easier to build and invoke unit tests, as well as to have a wrapper around xcodebuild to make general usage easier. Therefore we make the transition to xctool. xctool is available through homebrew. I recommend installing it on your local machine. If you have homebrew installed, open Terminal and execute brew update \u0026\u0026 brew install xctool to install it on your local machine. xctool can be used with the following parameters:\nxctool -workspace {Path.xcworkspace} -scheme {SchemeName} -sdk {SDK} XCtool also automatically compiles your CocoaPods if they are part of your workspace. For our example project, the build command looks like this:\nxctool -workspace ContinuousDistributionExample.xcworkspace -scheme ContinuousDistributionExample -sdk iphonesimulator Similar to the parameters xcodebuild uses, again, if you have a project instead of a workspace, replace -workspace with -project. To run our unit tests we use this command:\nxctool test -workspace ContinuousDistributionExample.xcworkspace -scheme ContinuousDistributionExampleTests -sdk iphonesimulator Now we need to put these commands in the right place within our .travis.yml file. Travis has a special build lifecycle that requires us to use the script section for this purpose. Change your .travis.yml file to look like this:\n# file: .travis.yml language: objective-c script: - xctool -workspace ContinuousDistributionExample.xcworkspace -scheme ContinuousDistributionExample -sdk iphonesimulator - xctool test -workspace ContinuousDistributionExample.xcworkspace -scheme ContinuousDistributionExampleTests -sdk iphonesimulator Note that if your Xcode project lives in a subfolder in your repo, be sure to give the full path from your repository’s root, such as ContinuousDistributionExample/ContinuousDistributionExample.xcworkspace. The . notation for the current folder to use relative paths doesn’t work here and will result in errors. Make sure to apply this to all paths in a subfolder through the course of this series. If you need to use absolute paths, you can use the $PWD env variable to get your current working directory, then expand the path further from there.\nUpdating Software \u0026\u0026 Dependencies As mentioned before, Travis CI provides the CocoaPods gem within their OS X environment. If you put your Podfile in the same directory as your .travis.yml file in your project’s repo, Travis will automatically install all your pods without any further configuration. We want to make sure we have the latest version of CocoaPods and other software we’re using, so let’s use this spot in the build lifecycle to update Cocoapods and xctool. Travis CI recommends using their before_install: hook to execute these commands. Add this code snippet to the end of your .travis.yml file:\n# file: .travis.yml before_install: - sudo gem install cocoapods - brew update - if brew outdated | grep -qx xctool; then brew upgrade xctool; fi Commit and push your changes. Travis should make a new build. Make sure everything works and your builds are passing by consulting Build History-\u003eBuild. Note: We want to upgrade xctool only if it’s outdated, because the chances that we’ll run into some brew link errors are quite high. While writing this post, I ran into a few problems with outdated software and iOS 8 due to recent releases of iOS and Xcode. If you get an error on Travis CI and not on your local machine, check the version numbers and consider updating to the same version. If you want to check your results at this point or just get a preconfigured version, you can check out the minimal version.\nCongratulations—you just integrated your first project using Travis CI! It should automatically build now and let you know once a commit breaks the building process.\nIn the next part of this series, we’re going to set up code signing on Travis CI so that we can deploy our releases later on\n",
  "wordCount" : "2049",
  "inLanguage": "en",
  "datePublished": "2016-10-21T17:28:00Z",
  "dateModified": "2016-10-21T17:28:00Z",
  "author":{
    "@type": "Person",
    "name": "Florian Harr"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://iflorian.com/continuous-deployment-with-travis-ci-and-hockeyapp-part-1/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "[self writeBlog];",
    "logo": {
      "@type": "ImageObject",
      "url": "https://iflorian.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://iflorian.com/" accesskey="h" title="[self writeBlog]; (Alt + H)">[self writeBlog];</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://iflorian.com/contact" title="Contact">
                    <span>Contact</span>
                </a>
            </li>
            <li>
                <a href="https://iflorian.com/about" title="About me">
                    <span>About me</span>
                </a>
            </li>
            <li>
                <a href="https://iflorian.com/euc" title="EUC">
                    <span>EUC</span>
                </a>
            </li>
            <li>
                <a href="https://iflorian.com/" title="My Blog">
                    <span>My Blog</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Continuous Deployment with Travis CI and HockeyApp, Part 1
    </h1>
    <div class="post-meta"><span title='2016-10-21 17:28:00 +0000 UTC'>October 21, 2016</span>&nbsp;·&nbsp;<span>Florian Harr</span>

</div>
  </header> 
  <div class="post-content"><p><strong>Full disclosure:</strong> I wrote this about 1-1.5yrs ago for another company but haven&rsquo;t updated it yet. There&rsquo;s a good chance some stuff is broken, I apologize for that and promise to fix it within the next days ;)</p>
<p>Continuous integration has become an important topic and a significant part of a developer’s workflow. Finding bugs and ensuring a stable codebase are among the most important benefits of using continuous integration. While these benefits are huge on their own, we can extend our continuous integration setup to actually deploy new builds of our application to our testers. We call this extended setup continuous deployment.</p>
<p>For most app developers, setting up an Xcode server and all of the necessary requirements to run a CI server are more of a hassle and a distraction than anything else. There are a couple of alternatives available to this approach, one of them being <a href="http://travis-ci.org/">Travis-CI</a>, a cloud-based continuous integration solution that conveniently takes away the hassle to setup a server.</p>
<p>In this series of tutorials, I would like to show you how to set up an existing Xcode project with Travis CI for automated builds. Later on, I’ll show you how to automatically distribute your builds using HockeyApp.
Let’s dive right in, starting with Travis CI. The only thing you need in order to follow along is an Xcode project hosted on GitHub.</p>
<h3 id="introducing-travis-ci">Introducing Travis CI<a hidden class="anchor" aria-hidden="true" href="#introducing-travis-ci">#</a></h3>
<p>Travis CI is basically a virtual machine provider, which gives us a Mac OS X machine with a software stack on top that includes the latest Xcode, Ruby and homebrew. The complete list of available gems, software and commands can be found in the Travis CI <a href="http://docs.travis-ci.com/user/osx-ci-environment/">docs</a>.</p>
<p>To begin setting up Travis CI, you first need an account. Fortunately, Travis can use your GitHub account and you’re done with that part in one click. Go to <a href="http://travis-ci.org/">travis-ci.org</a>, click on <code>Sign in with GitHub</code> in the upper right corner and log in with your GitHub Account.</p>
<p>Once you’re logged in with your GitHub account, Travis shows you your latest CI build in the form of a dashboard. The navigation is divided into three parts. The left sidebar displays your active CI projects with some quick info, the header above gives you some navigation possibilities with your personal settings on the right, and the main area in the center shows your currently selected CI project with the latest build log under the  <code>Current</code> tab.</p>
<p>Settings for your selected CI project are available through the gear icon on the upper right side, next to the  <code>build passing/failed/unknown’ button. All the information here is synchronized with GitHub, so new pushes lead to a new build under  </code>Build History,’ and any errors or simple logging output can be found in the Terminal-style dark box when you select a build.</p>
<p>There’s also an option to build your private repositories, though that’s a feature included only in paid plans, as the free plan is meant to support open source projects. Private repositories are configured through <a href="http://travis-ci.com/">travis-ci.com</a>.</p>
<p><img alt="List of repos" loading="lazy" src="/images/2016/10/ListOfRepos-II_TravisCI.png"></p>
<h3 id="get-your-repo-up-to-speed">Get Your Repo Up to Speed<a hidden class="anchor" aria-hidden="true" href="#get-your-repo-up-to-speed">#</a></h3>
<p>Once your repositories are fetched, you can enable your project for use with Travis by using the “ON/OFF” slider. Once you do that, Travis will start building the project even though Travis might not know how to properly do so just yet. I prefer to hold off Travis when no configuration file is available, by selecting “Build only if <code>.travis.yml</code> is present” in the project settings.</p>
<p>To do so, click on the <code>+</code> sign in the left sidebar, make sure your desired identity is selected and then activate your repository on the right by using the ON/OFF slider. Next, click on the wrench symbol next to the switch and you’ll get redirected to your project’s settings page. Activate the &ldquo;Build only if <code>.travis.yml</code> is present&rdquo; option.</p>
<p><img alt="Project Settings" loading="lazy" src="/images/2016/10/Project_Settings_TravisCI.png"></p>
<p>This brings us to the core configuration of Travis, the <code>.travis.yml</code> file. All settings, instructions and customized routines are set through Travis’s <code>.travis.yml</code> file, which has to be placed in your repository’s root. Therefore, we go forward and create an empty file with the name <code>.travis.yml</code> in our repository’s root, so Travis continues to build our project.</p>
<p>Note that you might not see this file through your file explorer, as most operating systems hide files with a dot prefix. Go ahead and commit that file to your repo, and Travis will continue to build it. Either use your favorite text editor or use  <code>cd {yourRepositoriy/Path/} | touch .travis.yml</code>
to create an empty <code>.travis.yml</code> file in your repo. Commit and push to GitHub.
You can and should check the existence of your <code>.travis.yml</code> on your GitHub’s overview page, as shown in the screenshot below.</p>
<p><img alt=".travis.yml exists" loading="lazy" src="/images/2016/10/TravisYMLExists.png"></p>
<p><strong>Note</strong>: Travis’s configuration file follows a customized YAML syntax, which can easily break. When writing the configuration file, be sure to use soft tabs (spaces) instead of real tabs and try to remind yourself that this will be parsed through bash when using whitespaces in commands.</p>
<h3 id="shared-xcode-schemes">Shared Xcode Schemes<a hidden class="anchor" aria-hidden="true" href="#shared-xcode-schemes">#</a></h3>
<p>Before we move along to the actual build process, we have to configure our project in Xcode to make our build targets available on the server. So far, the build targets have been created automatically, but that doesn’t happen on the server. To make our targets available on the server, we have to declare them as <code>Shared</code> targets.
To do this, open your project in Xcode, click on the project’s name next to the Build &amp; Run Button, where you normally select your deployment target, and select <code>Manage Schemes</code>. You should have at least two targets, one for your actual app and one for your Unit Test target as shown in the screenshot above. If not, go ahead and create them either through the  <code>+</code> Button or the  <code>Autocreate Schemes Now</code> Button.</p>
<p><img alt="Shared Xcode Scheme" loading="lazy" src="/images/2016/10/Shared_Targets-TravisCI.png"></p>
<p>Commit and push to GitHub. Make sure that your commit contains your shared scheme. It’s a common mistake for people to exclude the shared scheme through their .gitignore.</p>
<h3 id="under-the-hood">Under the Hood<a hidden class="anchor" aria-hidden="true" href="#under-the-hood">#</a></h3>
<p>At this point, you might ask yourself what Travis performs to build your project. As mentioned before, Travis is basically a VM provider and lets you modify its routine through bash scripts in order to build your projects. It’s no wonder that Travis uses Xcode’s command line tools to perform all actions on your project. The main command is  <code>xcodebuild</code>, which is invoked with some basic parameters. The basic pattern goes like this:</p>
<pre tabindex="0"><code>xcodebuild -project {XCodeproject.xcodeproj} -scheme {SchemeNem} -sdk {SDKname}
</code></pre><p>In our specific case, that command would look like this:</p>
<pre tabindex="0"><code>xcodebuild -project ContinuousDistributionExample.xcodeproj -scheme ContinuousDistributionExample -sdk iphonesimulator
The required parameters are -project {Path to your .xcodeproj}, -scheme {Your projects scheme name} and -sdk {SDK name}
</code></pre><p>If you have a Xcode workspace instead of a project, exchange the <code>-project</code> parameter for a <code>-workspace</code> parameter.
As with most, if not all, of the commands shown here, you can test these commands locally before testing them on Travis CI. For this specific command, just open your terminal and navigate with  <code>cd</code> into your repository and execute the same <code>xcodebuild</code> command. That way, you can see if your command works, and if there are any typos or other problems.</p>
<p>A lot could be said here about how to use <code>xcodebuild</code>, but as there are more advanced tools that work as a wrapper to <code>xcodebuild</code>, we’re going to move along and use <code>xctool</code> to replace it. In any case, you should make sure that your Xcode command line tools are working and up to date. You can check that by performing  <code>xcode-select –version</code> in your terminal.</p>
<p>###The Basic Setup
Now that you know how the xcodebuild command works, let’s start using it with Travis CI.
Modify the contents of your <code>.travis.yml</code> to match this code snippet, while making the appropriate customizations for your parameters:</p>
<pre tabindex="0"><code> # file: .travis.yml
language: objective-c
script:
  - xcodebuild -project ContinuousDistributionExample.xcodeproj -scheme ContinuousDistributionExample -sdk iphonesimulator
</code></pre><p>Travis CI defines a minimal configuration for an Objective-C project to have the keys language, <code>xcode_project</code> and <code>xcode_scheme</code> defined. If you try to use these, Travis will use your project’s default settings, which have a high chance to fail on Travis CI without prior changes.
Commit the file, and push your changes to your GitHub repo. If you put in the correct names and paths and you committed your configuration back to GitHub, Travis CI should start building your project. Make sure that the build passes at this point, so we can customize our routine from here. You can tell that your build is passing from either the log by clicking on the  <code>Build History</code> tab, or after refreshing the website from the  <code>build: status</code> button at the upper right section.</p>
<p><img alt="Build Passed" loading="lazy" src="/images/2016/10/Build_passed_TravisCI.png"></p>
<h3 id="xctool">XCTool<a hidden class="anchor" aria-hidden="true" href="#xctool">#</a></h3>
<p>xctool is a wrapper for Apple’s <code>xcodebuild</code>, which we were using before. The main purpose for switching from xcodebuild to xctool is to make it easier to build and invoke unit tests, as well as to have a wrapper around xcodebuild to make general usage easier. Therefore we make the transition to <code>xctool</code>.
xctool is available through homebrew. I recommend installing it on your local machine. If you have homebrew installed, open Terminal and execute <code>brew update &amp;&amp; brew install xctool</code> to install it on your local machine.
xctool can be used with the following parameters:</p>
<pre tabindex="0"><code>xctool -workspace {Path.xcworkspace} -scheme {SchemeName} -sdk {SDK}
</code></pre><p>XCtool also automatically compiles your CocoaPods if they are part of your workspace.
For our example project, the build command looks like this:</p>
<pre tabindex="0"><code>xctool -workspace ContinuousDistributionExample.xcworkspace -scheme ContinuousDistributionExample -sdk iphonesimulator
</code></pre><p>Similar to the parameters xcodebuild uses, again, if you have a project instead of a workspace, replace  <code>-workspace</code> with  <code>-project</code>.
To run our unit tests we use this command:</p>
<pre tabindex="0"><code>xctool test -workspace ContinuousDistributionExample.xcworkspace -scheme ContinuousDistributionExampleTests -sdk iphonesimulator
</code></pre><p>Now we need to put these commands in the right place within our .travis.yml file. Travis has a special build lifecycle that requires us to use the script section for this purpose.
Change your .travis.yml file to look like this:</p>
<pre tabindex="0"><code># file: .travis.yml
language: objective-c
script:
  - xctool -workspace ContinuousDistributionExample.xcworkspace -scheme ContinuousDistributionExample -sdk iphonesimulator
  - xctool test -workspace ContinuousDistributionExample.xcworkspace -scheme ContinuousDistributionExampleTests -sdk iphonesimulator
</code></pre><p>Note that if your Xcode project lives in a subfolder in your repo, be sure to give the full path from your repository’s root, such as  <code>ContinuousDistributionExample/ContinuousDistributionExample.xcworkspace</code>. The  <code>.</code> notation for the current folder to use relative paths doesn’t work here and will result in errors. Make sure to apply this to all paths in a subfolder through the course of this series. If you need to use absolute paths, you can use the  <code>$PWD</code> env variable to get your current working directory, then expand the path further from there.</p>
<h3 id="updating-software--dependencies">Updating Software &amp;&amp; Dependencies<a hidden class="anchor" aria-hidden="true" href="#updating-software--dependencies">#</a></h3>
<p>As mentioned before, Travis CI provides the CocoaPods gem within their OS X environment. If you put your Podfile in the same directory as your .travis.yml file in your project’s repo, Travis will automatically install all your pods without any further configuration.
We want to make sure we have the latest version of CocoaPods and other software we’re using, so let’s use this spot in the build lifecycle to update <code>Cocoapods</code> and <code>xctool</code>. Travis CI recommends using their  <code>before_install:</code> hook to execute these commands. Add this code snippet to the end of your <code>.travis.yml</code> file:</p>
<pre tabindex="0"><code> # file: .travis.yml
before_install:
  - sudo gem install cocoapods
  - brew update
  - if brew outdated | grep -qx xctool; then brew upgrade xctool; fi
</code></pre><p>Commit and push your changes. Travis should make a new build. Make sure everything works and your builds are passing by consulting Build History-&gt;Build.
Note: We want to upgrade xctool only if it’s outdated, because the chances that we’ll run into some brew link errors are quite high. While writing this post, I ran into a few problems with outdated software and iOS 8 due to recent releases of iOS and Xcode. If you get an error on Travis CI and not on your local machine, check the version numbers and consider updating to the same version.
If you want to check your results at this point or just get a preconfigured version, you can check out the minimal version.</p>
<p><strong>Congratulations</strong>—you just integrated your first project using Travis CI! It should automatically build now and let you know once a commit breaks the building process.</p>
<p>In the next part of this series, we’re going to set up code signing on Travis CI so that we can deploy our releases later on</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>All rights reserved - 2024</span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
